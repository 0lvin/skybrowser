diff --git a/gtkhtml/testgtkhtml.c b/gtkhtml/testgtkhtml.c
index c0de89b..9c7dcd9 100644
--- a/gtkhtml/testgtkhtml.c
+++ b/gtkhtml/testgtkhtml.c
@@ -90,7 +90,7 @@ static void goto_url(const char *url, int back_or_forward);
 static void on_set_base (GtkHTML *html, const gchar *url, gpointer data);
 
 static gchar *parse_href (const gchar *s);
-
+static gchar *decode(const gchar * token);
 static SoupSession *session;
 
 static GtkHTML *html;
@@ -673,6 +673,50 @@ got_data (SoupSession *session, SoupMessage *msg, gpointer user_data)
 	gtk_html_end (html, handle, GTK_HTML_STREAM_OK);
 }
 
+/*unescape url*/
+static gchar *
+decode(const gchar * token)
+{
+    const gchar *full_pos;
+    gchar *resulted;
+    gchar *write_pos;
+    const gchar *read_pos;
+
+    if (token == NULL)
+		return NULL;
+
+    /*stop pointer */
+    full_pos = token + strlen(token);
+    resulted = g_new(gchar, strlen(token) + 1);
+    write_pos = resulted;
+    read_pos = token;
+    while (read_pos < full_pos) {
+	size_t count_chars = strcspn(read_pos, "%");
+
+	memcpy(write_pos, read_pos, count_chars);
+	write_pos += count_chars;
+	read_pos += count_chars;
+	/*may be end string? */
+	if (read_pos < full_pos)
+	    if (*read_pos == '%') {
+		/*skip not needed % */
+		read_pos++;
+		if (*(read_pos) != 0)
+		    if (*(read_pos + 1) != 0) {
+				gchar save[3];
+				save[0]=*read_pos;
+				save[1]=*(read_pos + 1);
+				save[2]=0;
+				(*write_pos) = strtol(save, NULL, 16);
+				write_pos += 1;
+				read_pos += 2;
+		    }
+	    }
+    }
+    *write_pos = 0;
+    return resulted;
+}
+
 static void
 url_requested (GtkHTML *html, const char *url, GtkHTMLStream *handle, gpointer data)
 {
@@ -680,7 +724,34 @@ url_requested (GtkHTML *html, const char *url, GtkHTMLStream *handle, gpointer d
 
 	full_url = parse_href (url);
 
-	if (full_url && !strncmp (full_url, "http", 4)) {
+	if (full_url && !strncmp (full_url, "data", 4)) {
+		const gchar *real_action = full_url + strlen("data:");
+		const gchar *start_data = strchr(real_action, ';');
+		if (start_data != NULL) {
+			gchar *ContentType = NULL;
+			guchar *buf = NULL;
+			gsize ContentType_length = start_data - real_action;
+			ContentType = g_new(gchar, ContentType_length + 1);
+			memcpy(ContentType, real_action, ContentType_length);
+			*(ContentType + ContentType_length) = 0;
+			if (ContentType != NULL)
+				gtk_html_set_default_content_type (html, ContentType);
+			if (!strncmp(start_data, ";base64,", strlen(";base64,"))) {
+				gint state = 0;
+				guint save = 0;
+				gsize length = 0;
+				const gchar * toDecode = start_data + strlen(";base64,");
+				gchar *result_decode = decode(toDecode);
+				buf = g_new(guchar,(strlen(result_decode) * 3) / 4 + 1);
+				length = g_base64_decode_step(result_decode,
+					       strlen(result_decode),
+					       buf, &state, &save);
+				gtk_html_write (html, handle, (gchar *)buf, length);
+				gtk_html_end (html, handle, GTK_HTML_STREAM_OK);
+				g_free(result_decode);
+			}
+		}
+	} else if (full_url && !strncmp (full_url, "http", 4)) {
 		SoupMessage *msg;
 		msg = soup_message_new (SOUP_METHOD_GET, full_url);
 		soup_session_queue_message (session, msg, got_data, handle);
